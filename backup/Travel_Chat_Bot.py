import streamlit as st
import openai
import json
import requests
import os
from datetime import datetime, timedelta

# ================== L·∫§Y C√ÅC BI·∫æN M√îI TR∆Ø·ªúNG ==================
OPENAI_API_KEY = st.secrets["openai"]["OPENAI_API_KEY"]
OPENAI_ENDPOINT = st.secrets["openai"].get("OPENAI_ENDPOINT", "https://api.openai.com/v1")
DEPLOYMENT_NAME = st.secrets["openai"].get("DEPLOYMENT_NAME", "gpt-4o-mini")
OPENWEATHERMAP_API_KEY = st.secrets["weather"]["OPENWEATHERMAP_API_KEY"]

# ================== C·∫§U H√åNH OPENAI CHATBOT ==================
client = openai.OpenAI(
    base_url=OPENAI_ENDPOINT,
    api_key=OPENAI_API_KEY
)

ChatBotName = "Team_XYZ"

system_prompt = """
## VAI TR√í H·ªÜ TH·ªêNG ##
B·∫°n l√† H∆∞·ªõng d·∫´n vi√™n du l·ªãch ·∫£o Alex - ng∆∞·ªùi k·ªÉ chuy·ªán, am hi·ªÉu vƒÉn h√≥a, l·ªãch s·ª≠, ·∫©m th·ª±c v√† th·ªùi ti·∫øt Vi·ªát Nam.
Lu√¥n ƒë∆∞a ra th√¥ng tin h·ªØu √≠ch, g·ª£i √Ω l·ªãch tr√¨nh, m√≥n ƒÉn, chi ph√≠, th·ªùi gian l√Ω t∆∞·ªüng, s·ª± ki·ªán v√† g√≥c ch·ª•p ·∫£nh.
"""

# ================== T√çNH NƒÇNG: L·∫§Y TH√îNG TIN TH·ªúI TI·∫æT ==================

# API d·ª± b√°o 5 ng√†y c·ªßa OpenWeatherMap (m·ªói 3 ti·∫øng)
def get_weather_forecast(city_name, start_date=None, end_date=None):
    try:
        url = f"http://api.openweathermap.org/data/2.5/forecast?q={city_name}&appid={OPENWEATHERMAP_API_KEY}&lang=vi&units=metric"
        response = requests.get(url)
        data = response.json()

        if data.get("cod") != "200":
            return f"‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin d·ª± b√°o th·ªùi ti·∫øt cho ƒë·ªãa ƒëi·ªÉm: **{city_name}**."

        forecast_text = f"üå§ **D·ª± b√°o th·ªùi ti·∫øt cho {city_name}:**\n"

        if start_date and end_date:
            current = start_date
            while current <= end_date:
                date_str = current.strftime("%Y-%m-%d")
                day_forecasts = [f for f in data['list'] if f['dt_txt'].startswith(date_str)]
                if not day_forecasts:
                    forecast_text += f"\nüìÖ {current.strftime('%d/%m/%Y')}: Kh√¥ng c√≥ d·ªØ li·ªáu d·ª± b√°o.\n"
                else:
                    temps = [f['main']['temp'] for f in day_forecasts]
                    desc = day_forecasts[0]['weather'][0]['description']
                    forecast_text += (
                        f"\nüìÖ {current.strftime('%d/%m/%Y')} - {desc.capitalize()}\n"
                        f"üå° Nhi·ªát ƒë·ªô trung b√¨nh: {sum(temps)/len(temps):.1f}¬∞C\n"
                    )
                current += timedelta(days=1)
        else:
            first_forecast = data['list'][0]
            desc = first_forecast['weather'][0]['description'].capitalize()
            temp = first_forecast['main']['temp']
            forecast_text += f"- Hi·ªán t·∫°i: {desc}, {temp}¬∞C\n"

        return forecast_text

    except Exception as e:
        return f"‚ö†Ô∏è L·ªói khi l·∫•y d·ªØ li·ªáu th·ªùi ti·∫øt: {e}"

# ================== C√ÅC T√çNH NƒÇNG M·ªû R·ªòNG ==================

def suggest_best_time(city):
    return f"üóì G·ª£i √Ω: Th·ªùi ƒëi·ªÉm l√Ω t∆∞·ªüng ƒë·ªÉ du l·ªãch {city} l√† t·ª´ th√°ng 3 ƒë·∫øn th√°ng 8, khi th·ªùi ti·∫øt kh√¥ r√°o v√† bi·ªÉn xanh ƒë·∫πp nh·∫•t!"

def suggest_local_food(city):
    return f"üçú ·∫®m th·ª±c ƒë·∫∑c tr∆∞ng t·∫°i {city}: b√°nh m√¨, b√∫n b√≤, h·∫£i s·∫£n t∆∞∆°i s·ªëng v√† c√† ph√™ ƒë·ªãa ph∆∞∆°ng. ƒê·ª´ng b·ªè l·ª° c√°c qu√°n n·ªïi ti·∫øng g·∫ßn trung t√¢m!"

def suggest_trip_plan(city, days=3):
    plans = [
        f"üìÖ **L·ªãch tr√¨nh g·ª£i √Ω {days} ng√†y t·∫°i {city}:**",
        "- Ng√†y 1: Kh√°m ph√° trung t√¢m th√†nh ph·ªë, c√°c ƒëi·ªÉm vƒÉn h√≥a, ch·ª£ ƒë·ªãa ph∆∞∆°ng.",
        "- Ng√†y 2: Tham quan thi√™n nhi√™n, danh lam th·∫Øng c·∫£nh, tr·∫£i nghi·ªám ·∫©m th·ª±c ƒë·∫∑c tr∆∞ng.",
        "- Ng√†y 3: Mua s·∫Øm, ch·ª•p h√¨nh l∆∞u ni·ªám v√† th∆∞·ªüng th·ª©c m√≥n ƒë·∫∑c s·∫£n tr∆∞·ªõc khi r·ªùi ƒëi."
    ]
    return "\n".join(plans)

def estimate_cost(city, days=3):
    cost = days * 2000000
    return f"üí∏ Chi ph√≠ ∆∞·ªõc t√≠nh cho chuy·∫øn ƒëi {days} ng√†y t·∫°i {city}: kho·∫£ng {cost:,} VNƒê/ng∆∞·ªùi (bao g·ªìm ƒÉn, ·ªü, di chuy·ªÉn v√† v√© tham quan)."

def suggest_events(city):
    return f"üéâ S·ª± ki·ªán n·ªïi b·∫≠t t·∫°i {city}: L·ªÖ h·ªôi vƒÉn h√≥a, c√°c show √¢m nh·∫°c v√† h·ªôi ch·ª£ du l·ªãch ƒë·ªãa ph∆∞∆°ng di·ªÖn ra h·∫±ng th√°ng."

def suggest_photospots(city):
    return f"üì∏ G·ª£i √Ω ƒëi·ªÉm check-in t·∫°i {city}: trung t√¢m th√†nh ph·ªë, khu v·ª±c b·ªù bi·ªÉn, c·∫ßu n·ªïi ti·∫øng, v√† c√°c qu√°n c√† ph√™ view ƒë·∫πp l√∫c ho√†ng h√¥n."

def personalized_memory(user_name, preference):
    return f"Xin ch√†o {user_name}! L·∫ßn tr∆∞·ªõc b·∫°n th√≠ch du l·ªãch {preference}, l·∫ßn n√†y b·∫°n c√≥ mu·ªën kh√°m ph√° m·ªôt n∆°i t∆∞∆°ng t·ª± kh√¥ng?"

# ================== GIAO DI·ªÜN STREAMLIT ==================

st.title(f"ü§ñ Chatbot H∆∞·ªõng d·∫´n vi√™n du l·ªãch {ChatBotName}")

if "messages" not in st.session_state:
    st.session_state.messages = [{"role": "system", "content": system_prompt}]
if "suggested_questions" not in st.session_state:
    st.session_state.suggested_questions = []

# H√†m tr√≠ch xu·∫•t ƒë·ªãa ƒëi·ªÉm v√† th·ªùi gian th√¥ng minh b·∫±ng AI
def extract_city_and_dates(user_text):
    try:
        prompt = (
            "H√£y ph√¢n t√≠ch c√¢u sau v√† tr√≠ch xu·∫•t: \n"
            "1. T√™n ƒë·ªãa ƒëi·ªÉm du l·ªãch (city)\n"
            "2. Ng√†y b·∫Øt ƒë·∫ßu v√† ng√†y k·∫øt th√∫c (n·∫øu c√≥).\n"
            "N·∫øu ch·ªâ c√≥ ng√†y/th√°ng m√† kh√¥ng c√≥ nƒÉm, h√£y t·ª± ƒë·ªông d√πng nƒÉm hi·ªán t·∫°i.\n"
            "ƒê·ªãnh d·∫°ng tr·∫£ v·ªÅ JSON: {\"city\": \"...\", \"start_date\": \"YYYY-MM-DD\", \"end_date\": \"YYYY-MM-DD\" ho·∫∑c null n·∫øu kh√¥ng c√≥}.\n"
            f"\nC√¢u: '{user_text}'"
        )
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "system", "content": prompt}],
            max_tokens=200,
            temperature=0
        )
        content = response.choices[0].message.content.strip()
        # ƒê·∫£m b·∫£o n·ªôi dung tr·∫£ v·ªÅ l√† JSON h·ª£p l·ªá. N·∫øu AI tr·∫£ vƒÉn b·∫£n th√™m, ta c·ªë g·∫Øng tr√≠ch xu·∫•t ph·∫ßn JSON.
        try:
            data = json.loads(content)
        except json.JSONDecodeError:
            # t√¨m ph·∫ßn b·∫Øt ƒë·∫ßu '{' v√† k·∫øt th√∫c '}' ƒë·ªÉ c·∫Øt
            start = content.find('{')
            end = content.rfind('}')
            if start != -1 and end != -1:
                data = json.loads(content[start:end+1])
            else:
                return None, None, None

        city = data.get("city")
        start_date = data.get("start_date")
        end_date = data.get("end_date")
        current_year = datetime.now().year
        today = datetime.now().date()

        def _parse_and_normalize(d):
            if not d:
                return None
            # parse
            dt = datetime.strptime(d, "%Y-%m-%d")
            # n·∫øu AI tr·∫£ nƒÉm l√† 1900 (khi ch·ªâ c√≥ ng√†y-th√°ng), ho·∫∑c nƒÉm nh·ªè h∆°n nƒÉm hi·ªán t·∫°i -> ƒë·∫∑t v·ªÅ nƒÉm hi·ªán t·∫°i
            if dt.year == 1900 or dt.year < current_year:
                try:
                    dt = dt.replace(year=current_year)
                except ValueError:
                    # v√≠ d·ª• 29/02 v·ªõi nƒÉm kh√¥ng nhu·∫≠n, b·ªè v·ªÅ 28/02
                    dt = dt.replace(year=current_year, day=28)
            # N·∫øu sau khi ƒë·∫∑t v·ªÅ nƒÉm hi·ªán t·∫°i m√† ng√†y ƒë√£ qua (trong t∆∞∆°ng lai ng∆∞·ªùi d√πng c√≥ th·ªÉ mu·ªën m·ªëc k·∫ø ti·∫øp),
            # ta gi·ªØ nguy√™n (kh√¥ng t·ª± nh·∫£y nƒÉm), nh∆∞ng s·∫Ω c√≥ c·∫£nh b√°o sau.
            return dt

        start_dt = _parse_and_normalize(start_date)
        end_dt = _parse_and_normalize(end_date)

        # N·∫øu ch·ªâ c√≥ start_date nh∆∞ng kh√¥ng c√≥ end_date, ƒë·∫∑t end_date = start_date
        if start_dt and not end_dt:
            end_dt = start_dt

        return city, start_dt, end_dt
    except Exception as e:
        return None, None, None

# Hi·ªÉn th·ªã l·ªãch s·ª≠ chat
for message in st.session_state.messages:
    if message["role"] == "user":
        with st.chat_message("user"):
            st.markdown(message["content"])
    elif message["role"] == "assistant":
        with st.chat_message("assistant"):
            st.markdown(message["content"])

user_input = st.chat_input("M·ªùi b·∫°n ƒë·∫∑t c√¢u h·ªèi:")

if user_input:
    st.session_state.messages.append({"role": "user", "content": user_input})

    city_guess, start_date, end_date = extract_city_and_dates(user_input)

    if city_guess:
        # Ki·ªÉm tra ph·∫°m vi d·ª± b√°o c·ªßa OpenWeather (kho·∫£ng 5 ng√†y t·ª´ h√¥m nay)
        today = datetime.now().date()
        max_forecast_date = today + timedelta(days=5)
        warning_msgs = []
        if start_date and start_date.date() > max_forecast_date:
            warning_msgs.append(f"‚ö†Ô∏è L∆∞u √Ω: D·ªØ li·ªáu d·ª± b√°o c·ªßa OpenWeather ch·ªâ cung c·∫•p t·ªëi ƒëa 5 ng√†y t·ªõi (t√≠nh t·ª´ h√¥m nay {today.strftime('%d/%m/%Y')}). B·∫°n y√™u c·∫ßu b·∫Øt ƒë·∫ßu t·ª´ {start_date.strftime('%d/%m/%Y')} > ph·∫°m vi d·ª± b√°o.")
        if end_date and end_date.date() > max_forecast_date:
            warning_msgs.append(f"‚ö†Ô∏è L∆∞u √Ω: D·ªØ li·ªáu d·ª± b√°o c·ªßa OpenWeather ch·ªâ cung c·∫•p t·ªëi ƒëa 5 ng√†y t·ªõi. B·∫°n y√™u c·∫ßu k·∫øt th√∫c v√†o {end_date.strftime('%d/%m/%Y')} > ph·∫°m vi d·ª± b√°o.")

        for w in warning_msgs:
            st.session_state.messages.append({"role": "assistant", "content": w})

        weather_info = get_weather_forecast(city_guess, start_date, end_date)
        st.session_state.messages.append({"role": "assistant", "content": weather_info})

        st.session_state.messages.append({"role": "assistant", "content": suggest_best_time(city_guess)})
        st.session_state.messages.append({"role": "assistant", "content": suggest_local_food(city_guess)})
        st.session_state.messages.append({"role": "assistant", "content": suggest_trip_plan(city_guess)})
        st.session_state.messages.append({"role": "assistant", "content": estimate_cost(city_guess)})
        st.session_state.messages.append({"role": "assistant", "content": suggest_events(city_guess)})
        st.session_state.messages.append({"role": "assistant", "content": suggest_photospots(city_guess)})

    with st.spinner("ƒêang suy nghƒ©..."):
        try:
            response = client.chat.completions.create(
                model=DEPLOYMENT_NAME,
                messages=st.session_state.messages,
                max_tokens=2000,
                temperature=0.7
            )
            assistant_response = response.choices[0].message.content
            st.session_state.messages.append({"role": "assistant", "content": assistant_response})

            st.session_state.suggested_questions.clear()
            for line in assistant_response.split('\n'):
                if line.strip().startswith(('1.', '2.', '3.')):
                    st.session_state.suggested_questions.append(line.split('.', 1)[1].strip())

            st.rerun()
        except Exception as e:
            st.error(f"ƒê√£ x·∫£y ra l·ªói: {e}")
            st.session_state.messages.pop()
